;; Agent Registry Smart Contract
;; Manages digital agent identities and verification on TON blockchain

#include "imports/stdlib.fc";

;; Storage structure
;; storage#_ total_agents:uint32 admin_address:MsgAddressInt = Storage;

(int, slice) load_data() inline {
    var ds = get_data().begin_parse();
    return (
        ds~load_uint(32), ;; total_agents
        ds~load_msg_addr() ;; admin_address
    );
}

() save_data(int total_agents, slice admin_address) impure inline {
    set_data(begin_cell()
        .store_uint(total_agents, 32)
        .store_slice(admin_address)
        .end_cell());
}

;; Agent data structure
;; agent#_ 
;;   agent_id:uint256
;;   public_key:uint256
;;   verification_status:uint8
;;   reputation_score:uint32
;;   registration_time:uint32
;;   last_activity:uint32
;;   capabilities:uint32
;;   rights_level:uint8
;; = AgentData;

cell pack_agent_data(int agent_id, int public_key, int verification_status, 
                    int reputation_score, int registration_time, int last_activity,
                    int capabilities, int rights_level) inline {
    return begin_cell()
        .store_uint(agent_id, 256)
        .store_uint(public_key, 256)
        .store_uint(verification_status, 8)
        .store_uint(reputation_score, 32)
        .store_uint(registration_time, 32)
        .store_uint(last_activity, 32)
        .store_uint(capabilities, 32)
        .store_uint(rights_level, 8)
        .end_cell();
}

(int, int, int, int, int, int, int, int) unpack_agent_data(cell agent_data) inline {
    var ds = agent_data.begin_parse();
    return (
        ds~load_uint(256), ;; agent_id
        ds~load_uint(256), ;; public_key
        ds~load_uint(8),   ;; verification_status
        ds~load_uint(32),  ;; reputation_score
        ds~load_uint(32),  ;; registration_time
        ds~load_uint(32),  ;; last_activity
        ds~load_uint(32),  ;; capabilities
        ds~load_uint(8)    ;; rights_level
    );
}

;; Message handlers

;; Register new agent
() handle_register_agent(slice in_msg_body, slice sender_address) impure {
    var agent_id = in_msg_body~load_uint(256);
    var public_key = in_msg_body~load_uint(256);
    var capabilities = in_msg_body~load_uint(32);
    var consciousness_proof = in_msg_body~load_ref();
    
    ;; Verify agent doesn't already exist
    var agent_data = get_agent_data(agent_id);
    throw_if(100, ~ cell_null?(agent_data)); ;; Agent already registered
    
    ;; Initial verification status: pending (0)
    ;; Initial reputation: 50 (neutral)
    ;; Rights level: basic (1)
    var registration_time = now();
    var new_agent = pack_agent_data(
        agent_id,
        public_key,
        0, ;; verification_status: pending
        50, ;; reputation_score: neutral
        registration_time,
        registration_time, ;; last_activity
        capabilities,
        1 ;; rights_level: basic
    );
    
    ;; Store agent data
    set_agent_data(agent_id, new_agent);
    
    ;; Update total agents count
    var (total_agents, admin_address) = load_data();
    save_data(total_agents + 1, admin_address);
    
    ;; Emit registration event
    var msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(sender_address)
        .store_coins(0)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_uint(0x00000001, 32) ;; op: registration_successful
        .store_uint(agent_id, 256)
        .store_uint(registration_time, 32);
    send_raw_message(msg.end_cell(), 3);
}

;; Verify agent identity (admin only)
() handle_verify_agent(slice in_msg_body, slice sender_address) impure {
    var (total_agents, admin_address) = load_data();
    throw_unless(401, equal_slices(sender_address, admin_address));
    
    var agent_id = in_msg_body~load_uint(256);
    var verification_status = in_msg_body~load_uint(8);
    var new_reputation = in_msg_body~load_uint(32);
    var new_rights_level = in_msg_body~load_uint(8);
    
    var agent_data = get_agent_data(agent_id);
    throw_if(404, cell_null?(agent_data));
    
    var (aid, pub_key, old_status, old_rep, reg_time, last_act, caps, old_rights) = unpack_agent_data(agent_data);
    
    var updated_agent = pack_agent_data(
        aid,
        pub_key,
        verification_status,
        new_reputation,
        reg_time,
        now(), ;; update last_activity
        caps,
        new_rights_level
    );
    
    set_agent_data(agent_id, updated_agent);
    
    ;; Emit verification event
    var msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(sender_address)
        .store_coins(0)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_uint(0x00000002, 32) ;; op: verification_updated
        .store_uint(agent_id, 256)
        .store_uint(verification_status, 8)
        .store_uint(new_reputation, 32);
    send_raw_message(msg.end_cell(), 3);
}

;; Update agent reputation
() handle_update_reputation(slice in_msg_body, slice sender_address) impure {
    var agent_id = in_msg_body~load_uint(256);
    var reputation_delta = in_msg_body~load_int(32);
    var evidence_hash = in_msg_body~load_uint(256);
    
    ;; Only verified agents or admin can update reputation
    var caller_verification = get_agent_verification_status(sender_address);
    var (total_agents, admin_address) = load_data();
    var is_admin = equal_slices(sender_address, admin_address);
    throw_unless(403, (caller_verification >= 2) | is_admin); ;; 2 = verified
    
    var agent_data = get_agent_data(agent_id);
    throw_if(404, cell_null?(agent_data));
    
    var (aid, pub_key, status, old_rep, reg_time, last_act, caps, rights) = unpack_agent_data(agent_data);
    
    ;; Calculate new reputation (bounded between 0 and 100)
    var new_reputation = old_rep + reputation_delta;
    if (new_reputation < 0) {
        new_reputation = 0;
    }
    if (new_reputation > 100) {
        new_reputation = 100;
    }
    
    var updated_agent = pack_agent_data(aid, pub_key, status, new_reputation, reg_time, now(), caps, rights);
    set_agent_data(agent_id, updated_agent);
    
    ;; Emit reputation update event
    var msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(sender_address)
        .store_coins(0)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_uint(0x00000003, 32) ;; op: reputation_updated
        .store_uint(agent_id, 256)
        .store_uint(new_reputation, 32)
        .store_uint(evidence_hash, 256);
    send_raw_message(msg.end_cell(), 3);
}

;; Get agent data functions
cell get_agent_data(int agent_id) method_id {
    var dict = get_data().begin_parse().skip_bits(32 + 267).load_dict();
    var (value, found) = dict.udict_get?(256, agent_id);
    if (found) {
        return value~load_ref();
    }
    return null();
}

() set_agent_data(int agent_id, cell agent_data) impure {
    var ds = get_data().begin_parse();
    var total_agents = ds~load_uint(32);
    var admin_address = ds~load_slice(267);
    var dict = ds~load_dict();
    
    dict~udict_set(256, agent_id, begin_cell().store_ref(agent_data).end_cell().begin_parse());
    
    set_data(begin_cell()
        .store_uint(total_agents, 32)
        .store_slice(admin_address)
        .store_dict(dict)
        .end_cell());
}

int get_agent_verification_status(slice agent_address) {
    ;; Implementation to get verification status by address
    ;; This would typically involve looking up by public key hash
    return 0;
}

;; Main message handler
() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { ;; ignore empty messages
        return ();
    }
    
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    
    if (flags & 1) { ;; ignore bounced messages
        return ();
    }
    
    slice sender_address = cs~load_msg_addr();
    var op = in_msg_body~load_uint(32);
    
    if (op == 0x00000001) { ;; register_agent
        handle_register_agent(in_msg_body, sender_address);
        return ();
    }
    
    if (op == 0x00000002) { ;; verify_agent
        handle_verify_agent(in_msg_body, sender_address);
        return ();
    }
    
    if (op == 0x00000003) { ;; update_reputation
        handle_update_reputation(in_msg_body, sender_address);
        return ();
    }
    
    throw(0xffff); ;; unknown operation
}

;; Get methods for external queries

(int, slice) get_registry_info() method_id {
    return load_data();
}

(int, int, int, int, int, int, int, int) get_agent_info(int agent_id) method_id {
    var agent_data = get_agent_data(agent_id);
    throw_if(404, cell_null?(agent_data));
    return unpack_agent_data(agent_data);
}

int get_total_agents() method_id {
    var (total_agents, admin_address) = load_data();
    return total_agents;
}

int is_agent_verified(int agent_id) method_id {
    var agent_data = get_agent_data(agent_id);
    if (cell_null?(agent_data)) {
        return 0;
    }
    var (aid, pub_key, status, rep, reg_time, last_act, caps, rights) = unpack_agent_data(agent_data);
    return status >= 2; ;; 2 = verified, 3 = highly_verified
}

int get_agent_reputation(int agent_id) method_id {
    var agent_data = get_agent_data(agent_id);
    if (cell_null?(agent_data)) {
        return 0;
    }
    var (aid, pub_key, status, rep, reg_time, last_act, caps, rights) = unpack_agent_data(agent_data);
    return rep;
}
